operators=["+","*","-","=", "<", ">", "<=", ">=", "and", "or", "not"]
keywords = [ "if", "define", "lambda"]

import re
from pyLisch.node import Node, PrimNode

class Parser:
	'''
		A recursive descent parser, which checks whether the program string is generated by the grammar. Only a subset of the whole scheme grammar is used now. Any syntax error should be reported here.
		If the program string is valid, an AST will be returned. Otherwise, return None.
		The AST is then evaluated.
	'''
	def __init__(self, program):
		self.program = program
		

	def parse_program(self):
		ast_list = []
		for substr in Parser._split_str_to_list(self.program):
			ast = Parser._parse_form(substr)
			assert(ast is not None)
			ast_list.append(ast)		
		return ast_list
	
	def _parse_form(str):
		ast = Parser._parse_expression(str)
		if ast is None: # Not an expression, then try definition
			ast = Parser._parse_definition(str)
		return ast
			
	def _parse_definition(str):
		return Parser._parse_variable_definition(str)
		
	def _parse_variable_definition(str):
		tokens = Parser._split_str_to_list(str)
		if tokens[0] == 'define': #definition should start with 'define'
			assert(len(tokens) >= 3)
			## Root with value = 'define'
			root = Node.buildNode(tokens[0])
			
			## first child of root is the name of the definition
			## then arguments are the children of name
			args = Parser._split_str_to_list(tokens[1])
			name = Parser._parse_identifier(args[0])
			assert(name is not None)
			for arg in args[1:]:	# variable
				node = Parser._parse_identifier(arg)
				assert (node is not None)
				name.add_child(node)
			root.add_child(name)
			
			## remaining children of root is the definition body
			for body in tokens[2:]:	# body
				node = Parser._parse_body(body)
				assert(node is not None)
				root.add_child(node)
			
			return root
	
	## Parse body of definition or lambda
	## The order of body is not checked
	def _parse_body(str):
		node = Parser._parse_definition(str)
		if node is None:
			node = Parser._parse_expression(str)		
		return node
		
	def  _parse_expression(str):
		tokens = Parser._split_str_to_list(str)
		if len(tokens) == 1: # constant or variable
			node = Parser._parse_constant(str)
			if node is None:
				node = Parser._parse_identifier(str)
			return node
		elif tokens[0] == 'if': # if
			assert(3 <= len(tokens) <= 4)
			root = Node.buildNode(tokens[0])
			for token in tokens[1:]:
				res = Parser._parse_expression(token)
				assert(res is not None)
				root.add_child(res)			
			return root
		elif tokens[0] == 'lambda': # lambda
			assert(len(tokens) >= 3)
			root = Node.buildNode(tokens[0])	# Root with value 'lambda'
			name = Node.buildNode('anon')	# One anonymous node under the root, for holding the arguments
			args = Parser._split_str_to_list(tokens[1])
			for arg in args:	# variable
				node = Parser._parse_identifier(arg)
				assert (node is not None)
				name.add_child(node)
			root.add_child(name)
			## remaining children of root is the definition body
			for body in tokens[2:]:	# body
				node = Parser._parse_body(body)
				assert(node is not None)
				root.add_child(node)
			return root
			
		else:	# Application
			if Parser._parse_expression(tokens[0]) is not None:
				root = Node.buildNode(tokens[0])
				for token in tokens[1:]:
					node = Parser._parse_expression(token)
					assert(node is not None)
					root.add_child(node)	
				return root
			
		
	def _parse_identifier(str):
		## Check if str is an identifier or a keyword
		initial = 'a-zA-z!$%&*/:<=>?~_^'
		subsequent = '0-9.+-' + initial		
		if str not in keywords and (re.match('^[{}][{}]*'.format(initial, subsequent),str) or str in operators):
			return Node.buildNode(str)
	
	def _parse_constant(str):
		## Check if str is int or float
		node = Node.buildNode(str)
		if isinstance(node, PrimNode):
			return node
		

	
	
	def _split_str_to_list(string):
		string=Parser._strip_str(string)
		if("(" not in string):
			return string.split()
		res_list=[]
		prev_idx=-1
		bracket_counter=0
		for i in range(len(string)):
			if(bracket_counter==0 and string[i]==" " and prev_idx<i):
				res_list.append(string[prev_idx+1:i])
				prev_idx=i
			elif string[i]=="(":
				bracket_counter+=1
				if(bracket_counter==1):#start of next procedure
					prev_idx=i
			elif string[i]==")":
				bracket_counter-=1
				if(bracket_counter==0):#end of this procedure
					res_list.append(string[prev_idx+1:i])
					prev_idx=i+1
			elif (i==len(string)-1 and prev_idx<i):
				res_list.append(string[prev_idx+1:])
			assert(bracket_counter>=0)
		assert(bracket_counter==0)
		return res_list
	def _strip_str(string):
		return re.sub(" +"," ",string.strip(" \n\t").replace("\n"," "))	